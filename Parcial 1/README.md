<h1 align="center">Parcial 1 üò•</h1> 

1. Construya un programa que tenga una clase matriz (puede hacerlo con base en lo realizado en clase) que tenga un m√©todo implementado para solucionar un sistema de ecuaciones por el m√©todo Gauss-Jordan. La dimensi√≥n de la matriz es arbitraria y el programa debe decir si tiene soluci√≥n √∫nica, infinitas soluciones o √∫nica soluci√≥n. La clase debe tener un atributo llamado is valid que es una lista cuyo primer elemento es un Booleando indicando si todos los elementos de la matriz son n√∫meros o hay alg√∫n dato inv√°lido. Si el booleano es True, el segundo elemento de la lista ser√≠a una liusta vac√≠a, si es False, el segundo elemento de la lista ser√° una lista con los Indices de los elementos de la matriz que est√°n incorrectos. Ayuda: Si desea hagalo con un N m√°ximo de 5
2. Organice el ejemplo desarrollado en clase (el de matrices) para que los vectores puedan ser ingresados como una sola lista y no como lista de listas.Defina el producto entre matrices, vectores y escalares usando __mul__ y __rmul__ y defina un m√©todo para calcular la transpuesta de una matriz y otro uno para determinar si es sim√©trica.

<h1 align="center">Bit√°cora</h1>

El primer d√≠a se llev√≥ a cabo el c√≥digo para matrices cuadradas desde 2x2 hasta 5x5. Un c√≥digo largo (400 l√≠neas aprox.) pero no dif√≠cil, el cual fue una p√©rdida de tiempo ya que no era √∫til, pues, el m√©todo Gauss-Jordan se puede aplicar no necesariamente a matrices cuadradas y adem√°s de eso, solo con un n de 2 hasta 5, por lo que se defini√≥ las matrices nxm, con suma y resta de una manera arbitraria usando for anidados. Hasta ahora ha sido lo m√°s demorado, el hecho de entender bien la l√≥gica para desarrollar esa definici√≥n desde cero.
Se implement√≥ mul y rmul para llevar a cabo las multiplicaciones entre matrices y escalares, primero fue esto ya que para el m√©todo G-J es necesario la multiplicaci√≥n.

Por ahora la proyecci√≥n es primero definir un m√©todo para intercambiar filas, luego hacer gauss por aparte y luego hacer el jordan. Lo que se lleva hasta ahora no ha sido probado en ejemplos, voy suponiendo que el c√≥digo funciona de buena manera as√≠, despu√©s nos ocupamos de los errores que vayan saliendo. Hecho el intercambio de filas, al empezar con Gauss fue necesario primero a√±adir un m√©todo para encontrar el pivote, pues es necesario para seguir. Hecho Gauss, voy a proceder a hacer pruebas tanto de imprensi√≥n, suma, resta, multiplicaci√≥n, intercambio de l√≠neas y luego Gauss, para no tener problemas en un futuro con errores en conjunto.

El primer error sale a la luz, al momento de sumar y restar, la suma funcion√≥ de manera correcta pero la resta no funcion√≥. El problema no se deb√≠a directamente al c√≥digo, pasaba que si se imprim√≠a una primero que la otra, esa √∫ltima no serv√≠a, a√∫n no se soluciona esto. Al final el problema s√≠ estuvo en el c√≥digo, lo que hice fue modificar tanto el c√≥digo de add como el de sub, a√±adiendo una nueva lista donde se agregar√≠an los valores calculados de la nueva matriz y ya funcion√≥. Ahora las pruebas de la multiplicaci√≥n, el intercambio de filas y Gauss. El primer encuentro para tener en cuenta all√≠ es que la multiplicaci√≥n solo se defini√≥ entre matrices, no por escalar, por lo que se agregar√° eso, a√±adiendo un nuevo m√©todo para solo la multiplicaci√≥n por escalar, ya que el primer condicional de la multiplicaci√≥n es que sean iguales, un escalar es distinto a la matriz por lo que lo voy a tratar en otro m√©todo. Sigue habiendo un error ya que (*) se usa para multiplicar entre matrices y la matriz tiene un condicional para verificar que sean ambas matrices con el tama√±o apropiado, por lo que al ingresar un escalar lo ve como error, para eso se usar√° (.escalar) y as√≠ hasta ahora funciona correctamente mul, rmul y escalar. El m√©todo de Gauss tambi√©n funciona correctamente hasta ahora.

Una vez definido el m√©todo Gauss y Jordan, llegu√© a la conclusi√≥n de que hacerlos de manera separada era contraproducente ya que al momento de pedirlo en la consola tocar√≠a hacerlos por separado y no unificado, por lo que los voy a unir ambos en una sola definici√≥n. Tambi√©n no fue dif√≠cil hacer este m√©todo ya que el Jordan era solo invertir el orden del recorrido de las filas y ah√≠ aplicar las operaciones correspondientes a cada una.

Ahora se implementar√° un m√©todo para decidir si el sistema tiene √∫nica soluci√≥n, infinitas o no tiene. Esto lo hice usando los pivotes, primero se calcula el n√∫mero de variables en el sistema, que ser√≠a igual al n√∫mero de columnas menos una, la de los t√©rminos independientes. Luego, se itera a trav√©s de las filas de la matriz. Si una fila tiene todos los elementos iguales a cero, se considera una fila de ceros. Si una fila no es una fila de ceros, se busca el primer elemento no nulo en la fila. El √≠ndice de la columna de este elemento no nulo se agrega a la lista de pivotes. Despu√©s de iterar a trav√©s de todas las filas, se verifica el n√∫mero de pivotes que se han encontrado. Si hay un pivote para cada variable, el sistema tiene una soluci√≥n √∫nica. Si hay menos pivotes que variables, el sistema tiene infinitas soluciones. Si no hay suficientes pivotes para todas las variables y algunos t√©rminos independientes no son cero, entonces el sistema no tiene soluci√≥n.

Al hacer pruebas de la funcionalidad del c√≥digo "Tipo de soluci√≥n" se tiene el problema de que la definici√≥n de gauss-jordan solo emite una matriz, no da el vector resultado, por lo que se va a implementar un m√©todo de vector resultado. Despu√©s de implementar el resultado, se hicieron pruebas para ver la impresi√≥n del mismo y que no hayan c√≥digos en el mismo. Todo bien por ahora.

La siguiente parte del parcial se trata de ingresar un atributo llamado Is Valid, el cual recorre la matriz y verifica si cada elemento es un n√∫mero (int o float), en caso contrario agrega su √≠ndice a una lista de √≠ndices inv√°lidos. Si la lista est√° vac√≠a, entonces todos los elementos son n√∫meros y el atributo is_valid es una lista verdadera, indicando que la matriz es v√°lida. Si la lista no est√° vac√≠a, entonces la matriz contiene elementos inv√°lidos y el atributo is_valid es una lista [False, indices_invalidos], donde indices_invalidos es la lista con los √≠ndices de los elementos inv√°lidos. Y se a√±adi√≥ al principi√≥ del c√≥digo, no s√© si sea necesario s√≥lo a√±adirlo una vez, ya que al ser la encargada de correir y verificar los elementos, podr√≠a ser necesario ultilizarlo en cada definici√≥n, pero, se dejar√° solo en el inicio del c√≥digo esperando a errores futuros.

Despu√©s de terminar el punto 1 del parcial, puedo afirmar que la parte m√°s d√≠ficil fue definir el m√©todo matriz con su respectiva suma, multiplicaci√≥n, etc. Claramente lo otro no fue sencillo, pero el hecho del estudio necesario para entender a profundidad el ciclo for al momento de definir la matriz fue base suficiente para no tener problemas en el resto de definiciones del c√≥digo hasta ahora.

En el segundo punto, lo primero es organizar las matrices para que su ingreso sea como una lista y no como lista de listas, para esto voy a crear otra definici√≥n donde haya una lista vac√≠a y usando el ciclo for agregar cada sublista a la lista. No s√© si esto sea lo m√°s optimo para el ejemplo que se est√° desarrollando pero es lo que se me viene a la cabeza por ahora, si no ese apropiado, en el futuro se cambiar√° al momento de errores. Crear una nueva definici√≥n no sirvi√≥, por lo que voy a re-definir el __init__ de la clase matriz para que ahora sea una lista plana (esto es que se ingrese como una sola lista y no como lista de listas) con los valores de la matriz, por lo que toma tres par√°metros (valores, n, m). Al hacer la prueba s√≠ funciona la definici√≥n nueva en la que "self.valores" es una lista que contiene los valores de la matriz, donde "self.valores[i][j]" representa el valor en la fila i y la columna j de la matriz. 

El siguiente paso es definir el producto entre matrices, vectores y escalares, cosa que ya se hizo con anterioridad al momento de definir la clase matriz (que fue lo m√°s tardado), tambi√©n se implement√≥ esto por lo que ahora, el siguiente paso son dos m√©todos para definir la transpuesta de una matriz y determinar si la misma es sim√©trica. Lo primero es la transpuesta, la cual se define como intercambiar las filas por las columnas, por lo que se implement√≥ un m√©todo para este intercambio.
El m√©todo consiste en crear una nueva lista donde se contienen los elementos de la transpuesta, accediendo a cada elemento de la matriz original para construir la lista que represente la transpuesta.

Al momento de hacer pruebas, no funciona, adem√°s de eso hay errores en los m√©todos ya definidos, puede ser que se deba al hecho de que se cambi√≥ el __init__ y hay que ajustar los m√©todos para la nueva definici√≥n. Por lo que ahora la matriz se define como una sola lista, la suma tampocoo funciona y hay cuatro errores m√°s al intentar sumar dos matrices como una lista. El error se deb√≠a a la forma del return de la suma al momento de operarla por lo que se actualiz√≥ utilizando una lista plana con los elementos de la matriz resultante. Por lo que con la resta es el mimso procedimiento. Tampoco funciona la multiplicaci√≥n por escalar y probablemente tampoco funcione la multiplicaci√≥n entre matrices. Se us√≥ el mismo m√©todo de return empleado para la suma y la resta, porque al parecer, los errores son los mismos, la clase matriz espera tres argumentos definidos en el __init__ (valores, n, m) cosa que se a√±adi√≥ al momento de usar las listas planas, por lo que se cambi√≥ el return para as√≠ tener los argumentos v√°lidos, hasta ahora con la suma, resta y multiplicaci√≥n por escalar, preveo que en las otras partes del c√≥digo va a haber un error similar con los argumentos y espero la soluci√≥n sea la misma.

Al cambiar el return de mul y rmul, el c√≥digo igual no funcion√≥, este se deb√≠a a que la dimensi√≥n de la matriz resultante estaba tomando ambos valores de la primera matriz, cuando debe ser n de la primera y m de la segunda. Cambiando esto ya funciona la multiplicaci√≥n AB pero no la BA, no s√© a√∫n el porqu√© ya que cuando se hicieron pruebas antes de hacer la matriz plana y funcionaba correctamente. Incluso siendo los par√°metros correctos, m1=n2. No supe solucionar eso de la multiplicaci√≥n, a pesar que la multiplicaci√≥n entre matrices no ese conmutativa, hay unos par√°metros a seguir (m1=n2) igual con esto no funciona, solo se hace para un lado, por lo que por ahora lo voy a omitir esperando que no hayan problemas a futuro.

Haciendo nuevas pruebas en el c√≥digo, por lo que no serv√≠an varias cosas, cre√© un nuevo archivo .py para mirar l√≠nea por l√≠nea los errores, en teor√≠a hasta ahora va todo bien, pero al hacer pruebas con Gauss-Jordan hay un error de divisi√≥n entre cero, cosa que no es posible, nuevamente, no s√© porqu√© antes no pasaba esto, por lo que voy a a√±adir una confirmaci√≥n de que si la fila est√° nula, simplemente la salte y contin√∫e con la siguiente, as√≠ se evita la divisi√≥n entre cero. Primer a√±adiendo una condici√≥n en le definici√≥n del pivote para que compruebe si los elementos son distintos de cero. Dej√© lo del pivote sin terminar y empec√© a hacer los cambios anteriores en el __rmul__ por lo que la multiplicaci√≥n no serv√≠a bien y se deb√≠a a que los valores de otra y self estaban al rev√©s, al cambiar esto, el c√≥digo funcion√≥ para A * B y B * A.

Solo falta confirmar que G-J funcione para poder continuar con los objetivos del parcial. El problema era que la funci√≥n de G-J lo que hac√≠a era modificar la matriz original y yo en la consola estaba pidiendo como si fuese una nueva matriz, por ello no imprim√≠a nada y lo mismo pasaba cuando ped√≠a el tipo de soluci√≥n y si la soluci√≥n del sistema en vector, estaba creando una nueva variable pero estas definiciones cambiaban la matriz original, por lo que la nueva variable no imprim√≠a nada. Hasta ahora todo funcion√≥ con normalidad.
No se hizo pruebas con la transpuesta, me pas√≥ por alto, y produce un error de falta de argumentos, esto se debe a lo mismo que pas√≥ con la suma, resta, mul, etc. Al momento de cambiar la lista de listas a una sola lista, por lo que solo hay que cambiar el return con los argumentos apropiados y s√≠, funcion√≥ correctamente.

El siguiente paso en las instrucciones del parcial es definir un producto entre matrices, vectores y escalares usando __mul__ y __rmul__, esto ya estaba definido a medias, por lo que primero intent√© definir todas las clases de la matriz al principio del c√≥digo (y por ello luego el problema de las listas). Por lo que ahora se implementar√° la funci√≥n para determinar si la matriz es sim√©trica.

Teniendo todo esto, lo √∫ltimo que se implementar√° son los inputs para que la consola pueda escoger lo que se quiera hacer. V√≠ en internet una forma de hacer un men√∫ con condicionales por lo que har√© pruebas sobre ello para ver si es posible implementarlo sin errores.
Un primer error era que los valore se sumaban como cadenas (1+2=12), por lo que fue necesario convertir los valores en una lista de enteros para luego crear la matriz con la misma. Usando esa misma definici√≥n para crear las matrices se us√≥ en todo y haciendo pruebas funcion√≥ de buena manera. Como anotaci√≥n, el Gauss-Jordan al funcionar con pivotes solo sirve para matrices cuadradas.