<h1 align="center">Parcial 1 üò•</h1> 

#### Estudiante: *Jhon Sebastian Garc√≠a Barrera*

#### Programa de F√≠sica, Universidad del Quind√≠o, Marzo, 2023.

1. Construya un programa que tenga una clase matriz (puede hacerlo con base en lo realizado en clase) que tenga un m√©todo implementado para solucionar un sistema de ecuaciones por el m√©todo Gauss-Jordan. La dimensi√≥n de la matriz es arbitraria y el programa debe decir si tiene soluci√≥n √∫nica, infinitas soluciones o √∫nica soluci√≥n. La clase debe tener un atributo llamado is valid que es una lista cuyo primer elemento es un Booleando indicando si todos los elementos de la matriz son n√∫meros o hay alg√∫n dato inv√°lido. Si el booleano es True, el segundo elemento de la lista ser√≠a una liusta vac√≠a, si es False, el segundo elemento de la lista ser√° una lista con los Indices de los elementos de la matriz que est√°n incorrectos. Ayuda: Si desea hagalo con un N m√°ximo de 5
2. Organice el ejemplo desarrollado en clase (el de matrices) para que los vectores puedan ser ingresados como una sola lista y no como lista de listas.Defina el producto entre matrices, vectores y escalares usando __mul__ y __rmul__ y defina un m√©todo para calcular la transpuesta de una matriz y otro uno para determinar si es sim√©trica.

<h1 align="center">Bit√°cora</h1>

El primer d√≠a se llev√≥ a cabo el c√≥digo para matrices cuadradas desde 2x2 hasta 5x5. Un c√≥digo largo (400 l√≠neas aprox.) pero no dif√≠cil, el cual fue una p√©rdida de tiempo ya que no era √∫til, pues, el m√©todo Gauss-Jordan se puede aplicar no necesariamente a matrices cuadradas y adem√°s de eso, solo con un n de 2 hasta 5, por lo que se defini√≥ las matrices nxm, con suma y resta de una manera arbitraria usando for anidados. Hasta ahora ha sido lo m√°s demorado, el hecho de entender bien la l√≥gica para desarrollar esa definici√≥n desde cero.
Se implement√≥ mul y rmul para llevar a cabo las multiplicaciones entre matrices y escalares, primero fue esto ya que para el m√©todo G-J es necesario la multiplicaci√≥n.

Por ahora la proyecci√≥n es primero definir un m√©todo para intercambiar filas, luego hacer gauss por aparte y luego hacer el jordan. Lo que se lleva hasta ahora no ha sido probado en ejemplos, voy suponiendo que el c√≥digo funciona de buena manera as√≠, despu√©s nos ocupamos de los errores que vayan saliendo. Hecho el intercambio de filas, al empezar con Gauss fue necesario primero a√±adir un m√©todo para encontrar el pivote, pues es necesario para seguir. Hecho Gauss, voy a proceder a hacer pruebas tanto de imprensi√≥n, suma, resta, multiplicaci√≥n, intercambio de l√≠neas y luego Gauss, para no tener problemas en un futuro con errores en conjunto.

El primer error sale a la luz, al momento de sumar y restar, la suma funcion√≥ de manera correcta pero la resta no funcion√≥. El problema no se deb√≠a directamente al c√≥digo, pasaba que si se imprim√≠a una primero que la otra, esa √∫ltima no serv√≠a, a√∫n no se soluciona esto. Al final el problema s√≠ estuvo en el c√≥digo, lo que hice fue modificar tanto el c√≥digo de add como el de sub, a√±adiendo una nueva lista donde se agregar√≠an los valores calculados de la nueva matriz y ya funcion√≥. Ahora las pruebas de la multiplicaci√≥n, el intercambio de filas y Gauss. El primer encuentro para tener en cuenta all√≠ es que la multiplicaci√≥n solo se defini√≥ entre matrices, no por escalar, por lo que se agregar√° eso, a√±adiendo un nuevo m√©todo para solo la multiplicaci√≥n por escalar, ya que el primer condicional de la multiplicaci√≥n es que sean iguales, un escalar es distinto a la matriz por lo que lo voy a tratar en otro m√©todo. Sigue habiendo un error ya que (*) se usa para multiplicar entre matrices y la matriz tiene un condicional para verificar que sean ambas matrices con el tama√±o apropiado, por lo que al ingresar un escalar lo ve como error, para eso se usar√° (.escalar) y as√≠ hasta ahora funciona correctamente mul, rmul y escalar. El m√©todo de Gauss tambi√©n funciona correctamente hasta ahora.

Una vez definido el m√©todo Gauss y Jordan, llegu√© a la conclusi√≥n de que hacerlos de manera separada era contraproducente ya que al momento de pedirlo en la consola tocar√≠a hacerlos por separado y no unificado, por lo que los voy a unir ambos en una sola definici√≥n. Tambi√©n no fue dif√≠cil hacer este m√©todo ya que el Jordan era solo invertir el orden del recorrido de las filas y ah√≠ aplicar las operaciones correspondientes a cada una.

Ahora se implementar√° un m√©todo para decidir si el sistema tiene √∫nica soluci√≥n, infinitas o no tiene. Esto lo hice usando los pivotes, primero se calcula el n√∫mero de variables en el sistema, que ser√≠a igual al n√∫mero de columnas menos una, la de los t√©rminos independientes. Luego, se itera a trav√©s de las filas de la matriz. Si una fila tiene todos los elementos iguales a cero, se considera una fila de ceros. Si una fila no es una fila de ceros, se busca el primer elemento no nulo en la fila. El √≠ndice de la columna de este elemento no nulo se agrega a la lista de pivotes. Despu√©s de iterar a trav√©s de todas las filas, se verifica el n√∫mero de pivotes que se han encontrado. Si hay un pivote para cada variable, el sistema tiene una soluci√≥n √∫nica. Si hay menos pivotes que variables, el sistema tiene infinitas soluciones. Si no hay suficientes pivotes para todas las variables y algunos t√©rminos independientes no son cero, entonces el sistema no tiene soluci√≥n.

Al hacer pruebas de la funcionalidad del c√≥digo "Tipo de soluci√≥n" se tiene el problema de que la definici√≥n de gauss-jordan solo emite una matriz, no da el vector resultado, por lo que se va a implementar un m√©todo de vector resultado. Despu√©s de implementar el resultado, se hicieron pruebas para ver la impresi√≥n del mismo y que no hayan c√≥digos en el mismo. Todo bien por ahora.

La siguiente parte del parcial se trata de ingresar un atributo llamado Is Valid, el cual recorre la matriz y verifica si cada elemento es un n√∫mero (int o float), en caso contrario agrega su √≠ndice a una lista de √≠ndices inv√°lidos. Si la lista est√° vac√≠a, entonces todos los elementos son n√∫meros y el atributo is_valid es una lista verdadera, indicando que la matriz es v√°lida. Si la lista no est√° vac√≠a, entonces la matriz contiene elementos inv√°lidos y el atributo is_valid es una lista [False, indices_invalidos], donde indices_invalidos es la lista con los √≠ndices de los elementos inv√°lidos. Y se a√±adi√≥ al principi√≥ del c√≥digo, no s√© si sea necesario s√≥lo a√±adirlo una vez, ya que al ser la encargada de correir y verificar los elementos, podr√≠a ser necesario ultilizarlo en cada definici√≥n, pero, se dejar√° solo en el inicio del c√≥digo esperando a errores futuros.

Despu√©s de terminar el punto 1 del parcial, puedo afirmar que la parte m√°s d√≠ficil fue definir el m√©todo matriz con su respectiva suma, multiplicaci√≥n, etc. Claramente lo otro no fue sencillo, pero el hecho del estudio necesario para entender a profundidad el ciclo for al momento de definir la matriz fue base suficiente para no tener problemas en el resto de definiciones del c√≥digo hasta ahora.

En el segundo punto, lo primero es organizar las matrices para que su ingreso sea como una lista y no como lista de listas, para esto voy a crear otra definici√≥n donde haya una lista vac√≠a y usando el ciclo for agregar cada sublista a la lista. No s√© si esto sea lo m√°s optimo para el ejemplo que se est√° desarrollando pero es lo que se me viene a la cabeza por ahora, si no ese apropiado, en el futuro se cambiar√° al momento de errores. Crear una nueva definici√≥n no sirvi√≥, por lo que voy a re-definir el __init__ de la clase matriz para que ahora sea una lista plana con los valores de la matriz, por lo que toma tres par√°metros (valores, n, m). Al hacer la prueba s√≠ funciona la definici√≥n nueva en la que "self.valores" es una lista que contiene los valores de la matriz, donde "self.valores[i][j]" representa el valor en la fila i y la columna j de la matriz.